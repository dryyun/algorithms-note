# 啊哈!算法 - 第六章 最短路径

最短路径的一些不同解法。

求解最短路径，如果是每条边权重相同，使用广度搜索，如果每条边权重不同，使用深度搜索，其实就可以解出，本章讨论的是其他的方法。  

## Floyd Warshall

解决多源最短路径问题  

让任意两点（a，b）之间的距离变短，只能引入第三个点 k，通过 k 作为中转 ，a->k->b，才有可能缩短 a 到 b 的路程。  

时间复杂度 O(N<sup>3</sup>)    

```js
// 从 i 顶点到 j 顶点只经过前 k 个顶点的最短路径  
// 不能通过固定设置 i = 3，j = 2 求出 3-> 2 的最短路径，因为中间点的距离也会在经过 k 的时候减少，所以这里要循环 3 次  
for (let k = 0; k < n; k++) {
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (e[i][j] > e[i][k] + e[k][j]) {
                e[i][j] = e[i][k] + e[k][j];
            }
        }
    }
}
```

## Dijkstra 算法 - 通过边实现松弛  

解决单源最短路径  

基本思想，每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终找到源点到其余所有点的最短路径  

时间复杂度 O(N<sup>2</sup>)  


## Bellman-Ford - 解决负权边  

书中描述【无论是思想上还是代码实现上都堪称完美的最短路径算法】  



