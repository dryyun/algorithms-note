# 啊哈!算法 - 第七章 神奇的树

## 树
树 - 是不包含回路的连通无向图  
- 一棵树中任意两节点有且仅有唯一的一条路径连通  
- 一棵树如果有 n 个节点，那么就一定有 n-1 条边
- 在一棵树中加一条边将会构成一个回路

名词：根节点，父节点，子节点，叶节点，节点深度  

## 二叉树

特殊的树，每个节点最多有两个子节点  

- 满二叉树
- 完全二叉树，一颗二叉树出了最右边位置上有一个或者几个叶节点缺少外，其他都是满的，那么就是完全二叉树  

### 完全二叉树的存储

使用一维数组存储  
>  为了要满足完全二叉树的特性，且容易理解容易使用，所以使用数一维数组存储，数组下标是从 1 开始的，arr[0] = 0，元素 0 是不被使用了，这个在代码里是默认使用的  

![完全二叉树存储](./tree.png)  

父节点编号为 k，那么左子节点编号为 2*k，右子节点编号为 2*k+1  
如果子节点编号为 x，那么父节点编号为 x/2 取整，Math.floor(x/2)  
如果有 N 个节点，那么完全二叉树的高度是 log<sub>2</sub>N
最后一个非叶节点是第 n/2 个节点

典型应用 - 堆

## 堆  

#### 堆，特殊的完全二叉树

- 最小堆，所有父节点都比子节点小
- 最大堆

![堆](./heap.png)  

> 圆圈里面的数是值，圆圈上面的数字是这个节点的编号  

#### 堆排序应用
- 删除最小值，在新增一个数，求最小值，使用 siftdown 方法
- 仅新增一个值，只需要将元素插入数组末尾，使用 siftup 方法

#### 堆的建立
1、循环插入元素到数组，使用 siftup 方法  
2、直接把所有元素放入数组，从第 n/2 个节点往上到 1 节点，循环使用 siftdown 方法

#### 堆排序  
1、使用最小堆进行从小到大的排序，每次取出 h[1]，把 h[1] = h[n]，使用 siftdown(1)，循环 n 次  
2、使用最大堆进行从小到大的排序

## 并查集 

靠左原则 和 擒贼先擒王原则


